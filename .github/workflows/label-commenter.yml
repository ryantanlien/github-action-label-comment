name: performance-checklist

on: 
  pull_request:
    types: [labeled]

jobs:
  comment-pr:
    if: ${{ github.event.label.name == 'performance sensitive' }}
    runs-on: ubuntu-latest
    steps:
      - name: Comment Performance Checklist on PR
        uses: actions/github-script@v6
        with: 
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ github.event.pull_request.number }},
                body: 
                  `# Performance Check List
                  This is an automated performance check list generated by GitHub Actions.

                  You have labeled this PR as performance sensitive, and thusly a performance check must be done.

                  Directly edit this comment once you have gathered the necessary information below.

                  ## Checking SQL Queries

                  ### Confirming the SQL Query
                  If you have written code that runs inside a ROM repository, write out the SQL query being written by ROM:

                  The SQL query that ROM executes can be found by using \`binding.pry\` and running LE locally. Execute the new ROM method that executes queries against the database within \`pry-byebug\` or \`pry\`

                  > [!IMPORTANT]
                  > \`\`\`
                  > Write your generated SQL query here
                  > \`\`\`

                  Next steps: 
                  - If the SQL query written out contains a \`SELECT\` statement, go to the section: SELECT Queries: Query Plan
                  - If the SQL query written out contains an \`UPDATE\` statement, go to the section: Update Queries: AppSignal

                  ### SELECT Queries: Query Plan
                  > [!WARNING]
                  > ***This step must be performed by a senior engineer. If no reviewers are senior, tag a senior with production access to review the code.***

                  A query plan outlines the steps that are run by the database to perform your query. The query plan of a query is highly dependent on the type and quantity of data being changed. Therefore, query plans must be run on a production database. 

                  > [!CAUTION]
                  > The next section MUST BE COMPLETED BY A SENIOR ENGINEER WITH PRODUCTION ACCESS.
                  > Read all instructions carefully before executing anything against the production database.
                  > 
                  > 1. Generate the query plan for the \`SELECT\` query generated by ROM above.
                  > 2. Execute the following: \`\`\`EXPLAIN ANALYZE 'insert generated query from rom here' (without the single quotes)\`\`\`
                  >     a. ⚠️ The query being run against \`EXPLAIN ANALYZE\` will be run against the production database!
                  > 3. Analyze the results for defects and smells.
                  >
                  > An explanation of what \`EXPLAIN ANAYLZE\` does and how to use it can be found on the [offical Postgres docs ](https://www.postgresql.org/docs/current/using-explain.html#USING-EXPLAIN-ANALYZE)
                  > 
                  > It should look like this:
                  > \`\`\`
                  > EXPLAIN ANALYZE SELECT *
                  > FROM tenk1 t1, tenk2 t2
                  > WHERE t1.unique1 < 10 AND t1.unique2 = t2.unique2;
                  > 
                  >                                                            QUERY PLAN
                  > -------------------------------------------------------------------​--------------------------------------------------------------
                  >  Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual time=0.128..0.377 rows=10 loops=1)
                  >   ->  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) (actual time=0.057..0.121 rows=10 loops=1)
                  >          Recheck Cond: (unique1 < 10)
                  >          ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.024..0.024 rows=10 loops=1)
                  >                Index Cond: (unique1 < 10)
                  >   ->  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)
                  >          Index Cond: (unique2 = t1.unique2)
                  >  Planning time: 0.181 ms
                  >  Execution time: 0.501 ms
                  >  \`\`\`

                  > [!IMPORTANT]
                  > \`\`\`
                  > Write the results of the query plan here
                  > \`\`\`


                  ### UPDATE Queries: AppSignal Performance Tab 
                  In order to complete, this section, this PR must first be merged to \`develop\` and deployed on Ascenda's staging environment.

                  If the query is executed within a Sidekiq Worker, ensure that the worker does not cause any starvation issues by checking AppSignal's Sidekiq Dashboard while the worker is executing.

                  To check for whether the query is slow, check under the *Performance* tab of AppSignal, under *Slow Queries*. Navigate the UI to find the call stack for the queries, and check for red-coloured flags indicating potentially problematic queries.

                  > [!IMPORTANT]
                  > Paste a screenshot of the AppSignal performance tab for Sidekiq and/or *Slow Queries* tab here.

                  ## Final Confirmation Checklist 🏁 
                  - [ ] I have completed generating the raw SQL query being executed by ROM.
                  - [ ] I have checked the Query Plan / AppSignal for potential performance issues.`.split("\n").map(s => s.trim()).join("\n")
              });
              console.log('comment added')
            } catch (error) {
              console.log(error)
              console.log('comment adding failed')
            }
  block-merging-if-performance-check-not-done:
    if: ${{ contains(github.event.pull_request.labels.*name, 'needs performance check') && !contains(github.event.pull_request.labels.*.name, 'performance check done') }}
    runs-on: ubuntu-latest
    steps:
      - name: Block merging if performance check is not done but labeled as needs performance check
        run: |
          echo "Perform the performance check! Once done, add the 'performance check done' label."
          exit 1
  unblock-merging-if-performance-check-done: 
    if: $ {{ github.event.label.name == 'performance check done' }}
    runs-on: ubuntu-latest
    steps: 
      - name: Unblock merging if performance check is done
        if: ${{ contains(github.event.pull_request.labels.*.name, 'needs performance check') && contains(github.event.pull_request.labels.*.name, 'performance check done') }}
        run: |
          echo "Performance check labeled as done, unblocking merging!"
          exit 0
